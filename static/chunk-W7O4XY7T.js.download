import{m as S,n as a,p as k,q as m,v as M}from"./chunk-DNOI7M3U.js";S();M();S();M();typeof window!="undefined"&&window.__PREACT_DEVTOOLS__&&window.__PREACT_DEVTOOLS__.attachPreact("10.12.1",a,{Fragment:k,Component:m});var U={};function h(n){return n.type===k?"Fragment":typeof n.type=="function"?n.type.displayName||n.type.name:typeof n.type=="string"?n.type:"#text"}var T=[],g=[];function z(){return T.length>0?T[T.length-1]:null}var W=!1;function N(n){return typeof n.type=="function"&&n.type!=k}function c(n){for(var f=[n],l=n;l.__o!=null;)f.push(l.__o),l=l.__o;return f.reduce(function(u,d){u+="  in "+h(d);var p=d.__source;return p?u+=" (at "+p.fileName+":"+p.lineNumber+")":W||(W=!0,console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")),u+`
`},"")}var H=typeof WeakMap=="function";function A(n){return n?typeof n.type=="function"?A(n.__):n:{}}var J=m.prototype.setState;m.prototype.setState=function(n,f){return this.__v==null&&this.state==null&&console.warn(`Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.

`+c(z())),J.call(this,n,f)};var X=m.prototype.forceUpdate;function _(n){var f=n.props,l=h(n),u="";for(var d in f)if(f.hasOwnProperty(d)&&d!=="children"){var p=f[d];typeof p=="function"&&(p="function "+(p.displayName||p.name)+"() {}"),p=Object(p)!==p||p.toString?p+"":Object.prototype.toString.call(p),u+=" "+d+"="+JSON.stringify(p)}var E=f.children;return"<"+l+u+(E&&E.length?">..</"+l+">":" />")}m.prototype.forceUpdate=function(n){return this.__v==null?console.warn(`Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.

`+c(z())):this.__P==null&&console.warn(`Can't call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.

`+c(this.__v)),X.call(this,n)},function(){(function(){var t=a.__b,o=a.diffed,e=a.__,i=a.vnode,s=a.__r;a.diffed=function(r){N(r)&&g.pop(),T.pop(),o&&o(r)},a.__b=function(r){N(r)&&T.push(r),t&&t(r)},a.__=function(r,y){g=[],e&&e(r,y)},a.vnode=function(r){r.__o=g.length>0?g[g.length-1]:null,i&&i(r)},a.__r=function(r){N(r)&&g.push(r),s&&s(r)}})();var n=!1,f=a.__b,l=a.diffed,u=a.vnode,d=a.__e,p=a.__,E=a.__h,C=H?{useEffect:new WeakMap,useLayoutEffect:new WeakMap,lazyPropTypes:new WeakMap}:null,v=[];a.__e=function(t,o,e,i){if(o&&o.__c&&typeof t.then=="function"){var s=t;t=new Error("Missing Suspense. The throwing component was: "+h(o));for(var r=o;r;r=r.__)if(r.__c&&r.__c.__c){t=s;break}if(t instanceof Error)throw t}try{(i=i||{}).componentStack=c(o),d(t,o,e,i),typeof t.then!="function"&&setTimeout(function(){throw t})}catch(y){throw y}},a.__=function(t,o){if(!o)throw new Error(`Undefined parent passed to render(), this is the second argument.
Check if the element is available in the DOM/has the correct id.`);var e;switch(o.nodeType){case 1:case 11:case 9:e=!0;break;default:e=!1}if(!e){var i=h(t);throw new Error("Expected a valid HTML node as a second argument to render.	Received "+o+" instead: render(<"+i+" />, "+o+");")}p&&p(t,o)},a.__b=function(t){var o=t.type,e=A(t.__);if(n=!0,o===void 0)throw new Error(`Undefined component passed to createElement()

You likely forgot to export your component or might have mixed up default and named imports`+_(t)+`

`+c(t));if(o!=null&&typeof o=="object")throw o.__k!==void 0&&o.__e!==void 0?new Error("Invalid type passed to createElement(): "+o+`

Did you accidentally pass a JSX literal as JSX twice?

  let My`+h(t)+" = "+_(o)+`;
  let vnode = <My`+h(t)+` />;

This usually happens when you export a JSX literal and not the component.

`+c(t)):new Error("Invalid type passed to createElement(): "+(Array.isArray(o)?"array":o));if(o!=="thead"&&o!=="tfoot"&&o!=="tbody"||e.type==="table"?o==="tr"&&e.type!=="thead"&&e.type!=="tfoot"&&e.type!=="tbody"&&e.type!=="table"?console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent."+_(t)+`

`+c(t)):o==="td"&&e.type!=="tr"?console.error("Improper nesting of table. Your <td> should have a <tr> parent."+_(t)+`

`+c(t)):o==="th"&&e.type!=="tr"&&console.error("Improper nesting of table. Your <th> should have a <tr>."+_(t)+`

`+c(t)):console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent."+_(t)+`

`+c(t)),t.ref!==void 0&&typeof t.ref!="function"&&typeof t.ref!="object"&&!("$$typeof"in t))throw new Error(`Component's "ref" property should be a function, or an object created by createRef(), but got [`+typeof t.ref+`] instead
`+_(t)+`

`+c(t));if(typeof t.type=="string"){for(var i in t.props)if(i[0]==="o"&&i[1]==="n"&&typeof t.props[i]!="function"&&t.props[i]!=null)throw new Error(`Component's "`+i+'" property should be a function, but got ['+typeof t.props[i]+`] instead
`+_(t)+`

`+c(t))}if(typeof t.type=="function"&&t.type.propTypes){if(t.type.displayName==="Lazy"&&C&&!C.lazyPropTypes.has(t.type)){var s="PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try{var r=t.type();C.lazyPropTypes.set(t.type,!0),console.warn(s+"Component wrapped in lazy() is "+h(r))}catch(w){console.warn(s+"We will log the wrapped component's name once it is loaded.")}}var y=t.props;t.type.__f&&delete(y=function(w,O){for(var x in O)w[x]=O[x];return w}({},y)).ref,function(w,O,x,R,P){Object.keys(w).forEach(function(I){var b;try{b=w[I](O,I,R,"prop",null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(D){b=D}b&&!(b.message in U)&&(U[b.message]=!0,console.error("Failed prop type: "+b.message+(P&&`
`+P()||"")))})}(t.type.propTypes,y,0,h(t),function(){return c(t)})}f&&f(t)},a.__h=function(t,o,e){if(!t||!n)throw new Error("Hook can only be invoked from render methods.");E&&E(t,o,e)};var j=function(t,o){return{get:function(){var e="get"+t+o;v&&v.indexOf(e)<0&&(v.push(e),console.warn("getting vnode."+t+" is deprecated, "+o))},set:function(){var e="set"+t+o;v&&v.indexOf(e)<0&&(v.push(e),console.warn("setting vnode."+t+" is not allowed, "+o))}}},F={nodeName:j("nodeName","use vnode.type"),attributes:j("attributes","use vnode.props"),children:j("children","use vnode.props.children")},L=Object.create({},F);a.vnode=function(t){var o=t.props;if(t.type!==null&&o!=null&&("__source"in o||"__self"in o)){var e=t.props={};for(var i in o){var s=o[i];i==="__source"?t.__source=s:i==="__self"?t.__self=s:e[i]=s}}t.__proto__=L,u&&u(t)},a.diffed=function(t){if(t.__k&&t.__k.forEach(function(r){if(typeof r=="object"&&r&&r.type===void 0){var y=Object.keys(r).join(",");throw new Error("Objects are not valid as a child. Encountered an object with the keys {"+y+`}.

`+c(t))}}),n=!1,l&&l(t),t.__k!=null)for(var o=[],e=0;e<t.__k.length;e++){var i=t.__k[e];if(i&&i.key!=null){var s=i.key;if(o.indexOf(s)!==-1){console.error('Following component has two or more children with the same key attribute: "'+s+`". This may cause glitches and misbehavior in rendering process. Component: 

`+_(t)+`

`+c(t));break}o.push(s)}}}}();
